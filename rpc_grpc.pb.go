// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// RPCClient is the client API for RPC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RPCClient interface {
	// BEGIN NO AUTH
	AuthStatus(ctx context.Context, in *AuthStatusRequest, opts ...grpc.CallOption) (*AuthStatusResponse, error)
	AuthUnlock(ctx context.Context, in *AuthUnlockRequest, opts ...grpc.CallOption) (*AuthUnlockResponse, error)
	AuthLock(ctx context.Context, in *AuthLockRequest, opts ...grpc.CallOption) (*AuthLockResponse, error)
	Rand(ctx context.Context, in *RandRequest, opts ...grpc.CallOption) (*RandResponse, error)
	RandPassword(ctx context.Context, in *RandPasswordRequest, opts ...grpc.CallOption) (*RandPasswordResponse, error)
	AccountRegister(ctx context.Context, in *AccountRegisterRequest, opts ...grpc.CallOption) (*AccountRegisterResponse, error)
	AccountCreate(ctx context.Context, in *AccountCreateRequest, opts ...grpc.CallOption) (*AccountCreateResponse, error)
	AccountStatus(ctx context.Context, in *AccountStatusRequest, opts ...grpc.CallOption) (*AccountStatusResponse, error)
	AccountInvite(ctx context.Context, in *AccountInviteRequest, opts ...grpc.CallOption) (*AccountInviteResponse, error)
	AccountInviteAccept(ctx context.Context, in *AccountInviteAcceptRequest, opts ...grpc.CallOption) (*AccountInviteAcceptResponse, error)
	AccountSetUsername(ctx context.Context, in *AccountSetUsernameRequest, opts ...grpc.CallOption) (*AccountSetUsernameResponse, error)
	TeamCreate(ctx context.Context, in *TeamCreateRequest, opts ...grpc.CallOption) (*TeamCreateResponse, error)
	// Channels
	Channels(ctx context.Context, in *ChannelsRequest, opts ...grpc.CallOption) (*ChannelsResponse, error)
	ChannelCreate(ctx context.Context, in *ChannelCreateRequest, opts ...grpc.CallOption) (*ChannelCreateResponse, error)
	ChannelLeave(ctx context.Context, in *ChannelLeaveRequest, opts ...grpc.CallOption) (*ChannelLeaveResponse, error)
	ChannelRead(ctx context.Context, in *ChannelReadRequest, opts ...grpc.CallOption) (*ChannelReadResponse, error)
	ChannelUsers(ctx context.Context, in *ChannelUsersRequest, opts ...grpc.CallOption) (*ChannelUsersResponse, error)
	ChannelUsersAdd(ctx context.Context, in *ChannelUsersAddRequest, opts ...grpc.CallOption) (*ChannelUsersAddResponse, error)
	ChannelUsersRemove(ctx context.Context, in *ChannelUsersRemoveRequest, opts ...grpc.CallOption) (*ChannelUsersRemoveResponse, error)
	// Messages
	MessagePrepare(ctx context.Context, in *MessagePrepareRequest, opts ...grpc.CallOption) (*MessagePrepareResponse, error)
	MessageSend(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error)
	Messages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error)
	// Relay
	Relay(ctx context.Context, in *RelayRequest, opts ...grpc.CallOption) (RPC_RelayClient, error)
	// DB
	Collections(ctx context.Context, in *CollectionsRequest, opts ...grpc.CallOption) (*CollectionsResponse, error)
	Documents(ctx context.Context, in *DocumentsRequest, opts ...grpc.CallOption) (*DocumentsResponse, error)
}

type rPCClient struct {
	cc grpc.ClientConnInterface
}

func NewRPCClient(cc grpc.ClientConnInterface) RPCClient {
	return &rPCClient{cc}
}

func (c *rPCClient) AuthStatus(ctx context.Context, in *AuthStatusRequest, opts ...grpc.CallOption) (*AuthStatusResponse, error) {
	out := new(AuthStatusResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AuthStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AuthUnlock(ctx context.Context, in *AuthUnlockRequest, opts ...grpc.CallOption) (*AuthUnlockResponse, error) {
	out := new(AuthUnlockResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AuthUnlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AuthLock(ctx context.Context, in *AuthLockRequest, opts ...grpc.CallOption) (*AuthLockResponse, error) {
	out := new(AuthLockResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AuthLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Rand(ctx context.Context, in *RandRequest, opts ...grpc.CallOption) (*RandResponse, error) {
	out := new(RandResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/Rand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) RandPassword(ctx context.Context, in *RandPasswordRequest, opts ...grpc.CallOption) (*RandPasswordResponse, error) {
	out := new(RandPasswordResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/RandPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountRegister(ctx context.Context, in *AccountRegisterRequest, opts ...grpc.CallOption) (*AccountRegisterResponse, error) {
	out := new(AccountRegisterResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountRegister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountCreate(ctx context.Context, in *AccountCreateRequest, opts ...grpc.CallOption) (*AccountCreateResponse, error) {
	out := new(AccountCreateResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountStatus(ctx context.Context, in *AccountStatusRequest, opts ...grpc.CallOption) (*AccountStatusResponse, error) {
	out := new(AccountStatusResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountInvite(ctx context.Context, in *AccountInviteRequest, opts ...grpc.CallOption) (*AccountInviteResponse, error) {
	out := new(AccountInviteResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountInvite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountInviteAccept(ctx context.Context, in *AccountInviteAcceptRequest, opts ...grpc.CallOption) (*AccountInviteAcceptResponse, error) {
	out := new(AccountInviteAcceptResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountInviteAccept", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) AccountSetUsername(ctx context.Context, in *AccountSetUsernameRequest, opts ...grpc.CallOption) (*AccountSetUsernameResponse, error) {
	out := new(AccountSetUsernameResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/AccountSetUsername", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) TeamCreate(ctx context.Context, in *TeamCreateRequest, opts ...grpc.CallOption) (*TeamCreateResponse, error) {
	out := new(TeamCreateResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/TeamCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Channels(ctx context.Context, in *ChannelsRequest, opts ...grpc.CallOption) (*ChannelsResponse, error) {
	out := new(ChannelsResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/Channels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelCreate(ctx context.Context, in *ChannelCreateRequest, opts ...grpc.CallOption) (*ChannelCreateResponse, error) {
	out := new(ChannelCreateResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelLeave(ctx context.Context, in *ChannelLeaveRequest, opts ...grpc.CallOption) (*ChannelLeaveResponse, error) {
	out := new(ChannelLeaveResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelRead(ctx context.Context, in *ChannelReadRequest, opts ...grpc.CallOption) (*ChannelReadResponse, error) {
	out := new(ChannelReadResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelUsers(ctx context.Context, in *ChannelUsersRequest, opts ...grpc.CallOption) (*ChannelUsersResponse, error) {
	out := new(ChannelUsersResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelUsersAdd(ctx context.Context, in *ChannelUsersAddRequest, opts ...grpc.CallOption) (*ChannelUsersAddResponse, error) {
	out := new(ChannelUsersAddResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelUsersAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) ChannelUsersRemove(ctx context.Context, in *ChannelUsersRemoveRequest, opts ...grpc.CallOption) (*ChannelUsersRemoveResponse, error) {
	out := new(ChannelUsersRemoveResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/ChannelUsersRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) MessagePrepare(ctx context.Context, in *MessagePrepareRequest, opts ...grpc.CallOption) (*MessagePrepareResponse, error) {
	out := new(MessagePrepareResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/MessagePrepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) MessageSend(ctx context.Context, in *MessageSendRequest, opts ...grpc.CallOption) (*MessageSendResponse, error) {
	out := new(MessageSendResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/MessageSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Messages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error) {
	out := new(MessagesResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/Messages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Relay(ctx context.Context, in *RelayRequest, opts ...grpc.CallOption) (RPC_RelayClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPC_serviceDesc.Streams[0], "/service.RPC/Relay", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCRelayClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RPC_RelayClient interface {
	Recv() (*RelayOutput, error)
	grpc.ClientStream
}

type rPCRelayClient struct {
	grpc.ClientStream
}

func (x *rPCRelayClient) Recv() (*RelayOutput, error) {
	m := new(RelayOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCClient) Collections(ctx context.Context, in *CollectionsRequest, opts ...grpc.CallOption) (*CollectionsResponse, error) {
	out := new(CollectionsResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/Collections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCClient) Documents(ctx context.Context, in *DocumentsRequest, opts ...grpc.CallOption) (*DocumentsResponse, error) {
	out := new(DocumentsResponse)
	err := c.cc.Invoke(ctx, "/service.RPC/Documents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCServer is the server API for RPC service.
// All implementations must embed UnimplementedRPCServer
// for forward compatibility
type RPCServer interface {
	// BEGIN NO AUTH
	AuthStatus(context.Context, *AuthStatusRequest) (*AuthStatusResponse, error)
	AuthUnlock(context.Context, *AuthUnlockRequest) (*AuthUnlockResponse, error)
	AuthLock(context.Context, *AuthLockRequest) (*AuthLockResponse, error)
	Rand(context.Context, *RandRequest) (*RandResponse, error)
	RandPassword(context.Context, *RandPasswordRequest) (*RandPasswordResponse, error)
	AccountRegister(context.Context, *AccountRegisterRequest) (*AccountRegisterResponse, error)
	AccountCreate(context.Context, *AccountCreateRequest) (*AccountCreateResponse, error)
	AccountStatus(context.Context, *AccountStatusRequest) (*AccountStatusResponse, error)
	AccountInvite(context.Context, *AccountInviteRequest) (*AccountInviteResponse, error)
	AccountInviteAccept(context.Context, *AccountInviteAcceptRequest) (*AccountInviteAcceptResponse, error)
	AccountSetUsername(context.Context, *AccountSetUsernameRequest) (*AccountSetUsernameResponse, error)
	TeamCreate(context.Context, *TeamCreateRequest) (*TeamCreateResponse, error)
	// Channels
	Channels(context.Context, *ChannelsRequest) (*ChannelsResponse, error)
	ChannelCreate(context.Context, *ChannelCreateRequest) (*ChannelCreateResponse, error)
	ChannelLeave(context.Context, *ChannelLeaveRequest) (*ChannelLeaveResponse, error)
	ChannelRead(context.Context, *ChannelReadRequest) (*ChannelReadResponse, error)
	ChannelUsers(context.Context, *ChannelUsersRequest) (*ChannelUsersResponse, error)
	ChannelUsersAdd(context.Context, *ChannelUsersAddRequest) (*ChannelUsersAddResponse, error)
	ChannelUsersRemove(context.Context, *ChannelUsersRemoveRequest) (*ChannelUsersRemoveResponse, error)
	// Messages
	MessagePrepare(context.Context, *MessagePrepareRequest) (*MessagePrepareResponse, error)
	MessageSend(context.Context, *MessageSendRequest) (*MessageSendResponse, error)
	Messages(context.Context, *MessagesRequest) (*MessagesResponse, error)
	// Relay
	Relay(*RelayRequest, RPC_RelayServer) error
	// DB
	Collections(context.Context, *CollectionsRequest) (*CollectionsResponse, error)
	Documents(context.Context, *DocumentsRequest) (*DocumentsResponse, error)
	mustEmbedUnimplementedRPCServer()
}

// UnimplementedRPCServer must be embedded to have forward compatible implementations.
type UnimplementedRPCServer struct {
}

func (*UnimplementedRPCServer) AuthStatus(context.Context, *AuthStatusRequest) (*AuthStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthStatus not implemented")
}
func (*UnimplementedRPCServer) AuthUnlock(context.Context, *AuthUnlockRequest) (*AuthUnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthUnlock not implemented")
}
func (*UnimplementedRPCServer) AuthLock(context.Context, *AuthLockRequest) (*AuthLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthLock not implemented")
}
func (*UnimplementedRPCServer) Rand(context.Context, *RandRequest) (*RandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rand not implemented")
}
func (*UnimplementedRPCServer) RandPassword(context.Context, *RandPasswordRequest) (*RandPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RandPassword not implemented")
}
func (*UnimplementedRPCServer) AccountRegister(context.Context, *AccountRegisterRequest) (*AccountRegisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountRegister not implemented")
}
func (*UnimplementedRPCServer) AccountCreate(context.Context, *AccountCreateRequest) (*AccountCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountCreate not implemented")
}
func (*UnimplementedRPCServer) AccountStatus(context.Context, *AccountStatusRequest) (*AccountStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountStatus not implemented")
}
func (*UnimplementedRPCServer) AccountInvite(context.Context, *AccountInviteRequest) (*AccountInviteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInvite not implemented")
}
func (*UnimplementedRPCServer) AccountInviteAccept(context.Context, *AccountInviteAcceptRequest) (*AccountInviteAcceptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInviteAccept not implemented")
}
func (*UnimplementedRPCServer) AccountSetUsername(context.Context, *AccountSetUsernameRequest) (*AccountSetUsernameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountSetUsername not implemented")
}
func (*UnimplementedRPCServer) TeamCreate(context.Context, *TeamCreateRequest) (*TeamCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TeamCreate not implemented")
}
func (*UnimplementedRPCServer) Channels(context.Context, *ChannelsRequest) (*ChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Channels not implemented")
}
func (*UnimplementedRPCServer) ChannelCreate(context.Context, *ChannelCreateRequest) (*ChannelCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelCreate not implemented")
}
func (*UnimplementedRPCServer) ChannelLeave(context.Context, *ChannelLeaveRequest) (*ChannelLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelLeave not implemented")
}
func (*UnimplementedRPCServer) ChannelRead(context.Context, *ChannelReadRequest) (*ChannelReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelRead not implemented")
}
func (*UnimplementedRPCServer) ChannelUsers(context.Context, *ChannelUsersRequest) (*ChannelUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUsers not implemented")
}
func (*UnimplementedRPCServer) ChannelUsersAdd(context.Context, *ChannelUsersAddRequest) (*ChannelUsersAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUsersAdd not implemented")
}
func (*UnimplementedRPCServer) ChannelUsersRemove(context.Context, *ChannelUsersRemoveRequest) (*ChannelUsersRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUsersRemove not implemented")
}
func (*UnimplementedRPCServer) MessagePrepare(context.Context, *MessagePrepareRequest) (*MessagePrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagePrepare not implemented")
}
func (*UnimplementedRPCServer) MessageSend(context.Context, *MessageSendRequest) (*MessageSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageSend not implemented")
}
func (*UnimplementedRPCServer) Messages(context.Context, *MessagesRequest) (*MessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Messages not implemented")
}
func (*UnimplementedRPCServer) Relay(*RelayRequest, RPC_RelayServer) error {
	return status.Errorf(codes.Unimplemented, "method Relay not implemented")
}
func (*UnimplementedRPCServer) Collections(context.Context, *CollectionsRequest) (*CollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Collections not implemented")
}
func (*UnimplementedRPCServer) Documents(context.Context, *DocumentsRequest) (*DocumentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documents not implemented")
}
func (*UnimplementedRPCServer) mustEmbedUnimplementedRPCServer() {}

func RegisterRPCServer(s *grpc.Server, srv RPCServer) {
	s.RegisterService(&_RPC_serviceDesc, srv)
}

func _RPC_AuthStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AuthStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AuthStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AuthStatus(ctx, req.(*AuthStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AuthUnlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthUnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AuthUnlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AuthUnlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AuthUnlock(ctx, req.(*AuthUnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AuthLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AuthLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AuthLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AuthLock(ctx, req.(*AuthLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_Rand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Rand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/Rand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Rand(ctx, req.(*RandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_RandPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RandPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).RandPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/RandPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).RandPassword(ctx, req.(*RandPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountRegister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountRegister(ctx, req.(*AccountRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountCreate(ctx, req.(*AccountCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountStatus(ctx, req.(*AccountStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountInvite(ctx, req.(*AccountInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountInviteAccept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountInviteAcceptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountInviteAccept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountInviteAccept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountInviteAccept(ctx, req.(*AccountInviteAcceptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_AccountSetUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountSetUsernameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).AccountSetUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/AccountSetUsername",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).AccountSetUsername(ctx, req.(*AccountSetUsernameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_TeamCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TeamCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).TeamCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/TeamCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).TeamCreate(ctx, req.(*TeamCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_Channels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Channels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/Channels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Channels(ctx, req.(*ChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelCreate(ctx, req.(*ChannelCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelLeave(ctx, req.(*ChannelLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelRead(ctx, req.(*ChannelReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelUsers(ctx, req.(*ChannelUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelUsersAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUsersAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelUsersAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelUsersAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelUsersAdd(ctx, req.(*ChannelUsersAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_ChannelUsersRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUsersRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).ChannelUsersRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/ChannelUsersRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).ChannelUsersRemove(ctx, req.(*ChannelUsersRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_MessagePrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).MessagePrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/MessagePrepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).MessagePrepare(ctx, req.(*MessagePrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_MessageSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageSendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).MessageSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/MessageSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).MessageSend(ctx, req.(*MessageSendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_Messages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Messages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/Messages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Messages(ctx, req.(*MessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_Relay_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RelayRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RPCServer).Relay(m, &rPCRelayServer{stream})
}

type RPC_RelayServer interface {
	Send(*RelayOutput) error
	grpc.ServerStream
}

type rPCRelayServer struct {
	grpc.ServerStream
}

func (x *rPCRelayServer) Send(m *RelayOutput) error {
	return x.ServerStream.SendMsg(m)
}

func _RPC_Collections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Collections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/Collections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Collections(ctx, req.(*CollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPC_Documents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCServer).Documents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.RPC/Documents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCServer).Documents(ctx, req.(*DocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.RPC",
	HandlerType: (*RPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthStatus",
			Handler:    _RPC_AuthStatus_Handler,
		},
		{
			MethodName: "AuthUnlock",
			Handler:    _RPC_AuthUnlock_Handler,
		},
		{
			MethodName: "AuthLock",
			Handler:    _RPC_AuthLock_Handler,
		},
		{
			MethodName: "Rand",
			Handler:    _RPC_Rand_Handler,
		},
		{
			MethodName: "RandPassword",
			Handler:    _RPC_RandPassword_Handler,
		},
		{
			MethodName: "AccountRegister",
			Handler:    _RPC_AccountRegister_Handler,
		},
		{
			MethodName: "AccountCreate",
			Handler:    _RPC_AccountCreate_Handler,
		},
		{
			MethodName: "AccountStatus",
			Handler:    _RPC_AccountStatus_Handler,
		},
		{
			MethodName: "AccountInvite",
			Handler:    _RPC_AccountInvite_Handler,
		},
		{
			MethodName: "AccountInviteAccept",
			Handler:    _RPC_AccountInviteAccept_Handler,
		},
		{
			MethodName: "AccountSetUsername",
			Handler:    _RPC_AccountSetUsername_Handler,
		},
		{
			MethodName: "TeamCreate",
			Handler:    _RPC_TeamCreate_Handler,
		},
		{
			MethodName: "Channels",
			Handler:    _RPC_Channels_Handler,
		},
		{
			MethodName: "ChannelCreate",
			Handler:    _RPC_ChannelCreate_Handler,
		},
		{
			MethodName: "ChannelLeave",
			Handler:    _RPC_ChannelLeave_Handler,
		},
		{
			MethodName: "ChannelRead",
			Handler:    _RPC_ChannelRead_Handler,
		},
		{
			MethodName: "ChannelUsers",
			Handler:    _RPC_ChannelUsers_Handler,
		},
		{
			MethodName: "ChannelUsersAdd",
			Handler:    _RPC_ChannelUsersAdd_Handler,
		},
		{
			MethodName: "ChannelUsersRemove",
			Handler:    _RPC_ChannelUsersRemove_Handler,
		},
		{
			MethodName: "MessagePrepare",
			Handler:    _RPC_MessagePrepare_Handler,
		},
		{
			MethodName: "MessageSend",
			Handler:    _RPC_MessageSend_Handler,
		},
		{
			MethodName: "Messages",
			Handler:    _RPC_Messages_Handler,
		},
		{
			MethodName: "Collections",
			Handler:    _RPC_Collections_Handler,
		},
		{
			MethodName: "Documents",
			Handler:    _RPC_Documents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Relay",
			Handler:       _RPC_Relay_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "rpc.proto",
}
